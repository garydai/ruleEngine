---
layout: default

title: jvm

---

## jvm

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/jvm.jpg)

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/jvm2.jpg)

### 内存模型
![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/jvm.png)

![](https://github.com/garydai/garydai.github.com/raw/master/_posts/pic/jvm2.png)



#### 程序计数器（线程私有）

#### 虚拟机栈（线程私有）

#### 本地方法栈

#### java堆（线程共有）
存放对象实例，垃圾收集器管理的区域

#### 方法区（线程共有）
虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码

存放类信息（类名、访问修饰符、常量池、字段描述、方法描述）
#### 运行时常量池（方法区一部分）

#### 直接内存

### 对象的内存布局
对象头

实例数据

对齐填充

### 垃圾回收
引用计数（java没用）

可达性分析算法(java使用)
#### 垃圾回收算法
标记-清除算法

复制算法（现在商业虚拟机用该算法回收新生代）

标记-整理算法（现在商业虚拟机用该算法回收老生代）

分代收集算法（现在商业虚拟机采用以上两个算法）

### 虚拟机性能监控
jps：虚拟机进程状况工具

jstat：虚拟机统计信息监视工具

jinfo：java配置信息工具

jmap：java内存映射工具

jhat：堆转储快照分析工具

jstack：堆栈跟踪工具

-vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了

-Xms128m JVM初始分配的堆内存，默认是物理内存的1/64

-Xmx512m JVM最大允许分配的堆内存，默认是物理内存的1/4

-XX:PermSize=64M JVM初始分配的非堆内存，默认是物理内存的1/64

-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，默认是物理内存的1/4





### Class
常量池：Class文件开头有常量池入口，主要存放字面量，符号引用（类和接口、字段、方法的名字和描述符）

虚拟机加载class文件的时候进行动态链接，所以class文件不会保存各个方法、字段的最终内存布局信息


字段表、方法表有指向常量池的指针，用常量池来描述。



### java执行引擎工作原理：方法调用
jvm用c/c++编写，可以直接调用机器代码

### 字节码
magicNumber

version

常量池constant_pool_count

constant_pool[]

Access_flag

this_class

super_class

Interfaces

interfaces_count

interfaces[]

fields_count

fields[]

methods_count

void <clinit> 类的初始化都在该函数里，包括静态变量和static{}包围的程序的初始化

method[]

attributes_count

attributes[]

### oop-klass
klass保存类元信息，保存在perm永久区，oop保存类实例，保存在heap堆区

### 类加载
加载

验证

文件格式、元数据验证、字节码验证、符号引用验证

准备

解析

初始化



### jni

java程序调用c、c++函数

例如：

线程的一种实现：

java thread 通过jvm调用os的pthread_create，创建线程，然后jni反向调用java thread的run函数

start --- native start0 --- pthread_create(java_start) 

java_start 反向调用 run函数



```
JNI的步骤
		装载库，保证JVM在启动的时候就会装载，故而一般是也给static
	System.loadLibrary( "HelloNative" );
		编译成class文件
	javac xxxx
		生成.h头文件
	javah 报名+类名
		生存的。h文件需要放到包当中
	编写C文件，C文件的方法需要参考.h文件	NIEnv *env, jobject c1
	编译一个动态链接库
		gcc  -fPIC -I /usr/lib/jvm/java-1.8.0-openjdk/include -I /usr/lib/jvm/java-1.8.0-openjdk/include/linux  -shared -o liblubanNet.so server.c
	把这个库所在的目录添加到path
		export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxxxx
```

### 执行引擎
字节码被模版解释器解析成机器码

call_stub是实现jvm c程序调用java机器码的第一步，在jvm执行java主程序对应的第一条字节码指令之前，必须经过call_stub函数指针进入对应的例程，在目标例程中触发对java主函数第一条字节码指令的调用.

所以是先到例程，再到java函数，两个都是机器指令，例程是jvm启动时候生成的一段机器指定
```
 CallStub是一个函数指针。

 // Calls to Java
  typedef void (*CallStub)(
    address   link,
    intptr_t* result,
    BasicType result_type,
    Method* method,
    address   entry_point,
    intptr_t* parameters,
    int       size_of_parameters,
    TRAPS
  );


  static CallStub call_stub()    { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }

  
  _call_stub_entry在之前已经初始化过

	StubRoutines::_call_stub_entry = generate_call_stub(StubRoutines::_call_stub_return_address);

  jvm启动过程
  java.c: main()
	java_md.c: LoadJavaVM()
		jni.c: JNI_CreateJavaVM()
			Threads.c: create_vm()
				init.c: init_globals()
					StubRoutines.cpp: stubRoutines_init1()
						StubRoutines.cpp: initialize1()
							StubGenerator_x86_x32.cpp: StubGenerator_generate()
								StubGenerator_x86_x32.cpp: StubCodeGenerator()
									StubGenerator_x86_x32.cpp: generate_initial()
										StubGenerator_x86_x32.cpp: generate_call_stub()

_call_stub_entry例程

address generate_call_stub(address& return_address) {
    StubCodeMark mark(this, "StubRoutines", "call_stub");
    address start = __ pc();

    // stub code parameters / addresses
    assert(frame::entry_frame_call_wrapper_offset == 2, "adjust this code");
    bool  sse_save = false;
    const Address rsp_after_call(rbp, -4 * wordSize); // same as in generate_catch_exception()!
    const int     locals_count_in_bytes  (4*wordSize);
    const Address mxcsr_save    (rbp, -4 * wordSize);
    const Address saved_rbx     (rbp, -3 * wordSize);
    const Address saved_rsi     (rbp, -2 * wordSize);
    const Address saved_rdi     (rbp, -1 * wordSize);
    const Address result        (rbp,  3 * wordSize);
    const Address result_type   (rbp,  4 * wordSize);
    const Address method        (rbp,  5 * wordSize);
    const Address entry_point   (rbp,  6 * wordSize);
    const Address parameters    (rbp,  7 * wordSize);
    const Address parameter_size(rbp,  8 * wordSize);
    const Address thread        (rbp,  9 * wordSize); // same as in generate_catch_exception()!
    sse_save =  UseSSE > 0;

    // stub code
    __ enter();
    __ movptr(rcx, parameter_size);              // parameter counter
    __ shlptr(rcx, Interpreter::logStackElementSize); // convert parameter count to bytes
    __ addptr(rcx, locals_count_in_bytes);       // reserve space for register saves
    __ subptr(rsp, rcx);
    __ andptr(rsp, -(StackAlignmentInBytes));    // Align stack

    // save rdi, rsi, & rbx, according to C calling conventions
    __ movptr(saved_rdi, rdi);
    __ movptr(saved_rsi, rsi);
    __ movptr(saved_rbx, rbx);

    // save and initialize %mxcsr
    if (sse_save) {
      Label skip_ldmx;
      __ stmxcsr(mxcsr_save);
      __ movl(rax, mxcsr_save);
      __ andl(rax, MXCSR_MASK);    // Only check control and mask bits
      ExternalAddress mxcsr_std(StubRoutines::addr_mxcsr_std());
      __ cmp32(rax, mxcsr_std);
      __ jcc(Assembler::equal, skip_ldmx);
      __ ldmxcsr(mxcsr_std);
      __ bind(skip_ldmx);
    }

    // make sure the control word is correct.
    __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));




_call_stub_entry例程的作用就是一段机器代码，做的事情是进入java主函数机器代码之前，把栈环境配置好，因为是两段独立环境的代码，jvm和java，调用函数前会有很多栈的操作（函数入参压栈，调用前的环境压栈），需要要手动配置栈。而同一个环境例如java函数之间的调用，编译器会帮我们配置栈环境。

所以通过jvm事先写好的例程，使得程序调用可以在jvm和java之间穿梭，jvm可以调用java，java可以调用jvm。
```